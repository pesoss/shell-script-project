Скриптът започва със "shebang", където указваме какъв да е 
интерпретаторът на скрипта (в случая е "bash").

Първо дефинирам функцията "error_fn()", която извиквам всеки път когато 
може да възникне грешка. Функцията трябва да према два аргумента, 
първият трябва да бъде текст, който пренасочвам към "std error-а",
а вторият е "exit code". Във функцията проверявам и броя на аргументите,
с които е извикана. Те задължително трябва да са два.

Втората функция, която дефинирам е "ststus_code()". Тя проверява статус кода, който
получаваме след изпълнението на дадена команда. Функцията трябва да се извиква с 
два аргумента. Първият е "${?}", което е статус кода на последната извикана 
команда, а вторият аргумент е съобщението кото принтим на "std error-a".

Третата функция, която дефинирам е "most_important_funxtion()". Тя върши
основната работа на скрипта. За да я обесня, ще разделя кода на няколко 
последователни части, всяка от която започва с (-).

- Аргументи:
	Функцията трябва да се извиква със седем аргумента(правя проверка за 
броя на аргументните, ако е различен от 7 извиквам функцията "error_fn",).
Първият аргумент е файла, който трябва да разпакетираме. Вторият е директория 
в която разпакетирам файла. Третият е вторият аргумент с който е извикан скрипта. 
Четвъртия е коректният факултетен номер на студент. Петия е директория, в която 
разпакетирам файла. Шестия е стринг който указва какъв формат е файла, от това 
зависи как ще го разпакетирам (xz/POSIX/gzip/bzip2/zip/rar). Седмият аргумент е 
директория, която ползвам само при разпакетирането на "zip" и "rar".
	
- Променливи:
	Всеки един от аргументите съм го запил в променлива, за да е по-разбираемо, 
когато човек чете функцията. Също така имам и две променливи, които са регекси, 
които мачват факултетен номер (съдиржащ само главни букви и цифри) и "txt" фаилове, 
които съдържат само главни и малки букви, и завършват с ".txt".

- Проверка на формата на файла, който трябва да се разпакетира:
	Имаме три варианта на разпакетиране:
		1. "tar -xvf", който рапакетира (xz/POSIX/gzip/bzip2).
		2. "unzip file -d directory", който разпакетира (zip).
		3. "unrar -x file directory", който разпакетира (rar).

	1.Първо проверявам дали шестият аргумент е равен на (xz/POSIX/gzip/bzip2), ако е 
едно от посочените правя проверка дали при разпакетирането се получава директория, 
която съдържа файловете. 
	Описание на проверката (ред 40):
		Разпакетирам файла. "std out-a" от разпакетирането пренасозвам към "sed", 
	който премахва "./", ако има такива. Получения резултат пренасочвам към "egrep", 
	с опция "-q", която е го "държи тих :)". Командата проверява дали при 
	разпакетирането се е получил ред, който да бъде мачнат от регекса. Регекса е 
	ред, който започва с факултетния номер на студента последван от "/" и след 
	това да има файл, който е ".txt" формат и съдържа само малки и главни букви.
	Ако тази проверка не мине влизаме в "if-a", където създаваме директория с име 
	факултетния номер на студента, която се намира в директорията подадена като 
	трети аргумент на скрипта. Проверявам статус кода, дали директорията е 
	създадена успешно. (ред 45) - рапакетирам файла в директорията подадена като 
	петия аргумент и проверявам статус кода. (ред 48) с командата "find" намирам 
	всички обикновени фаилове в директорията подадена като пети аргумент и с 
	командата "xargs" копирам рекурсивно резултата от "find" в директорията с име 
	факултетен номер на студента, намираща се в директорията подадена като трети 
	аргумент на скрипта.
	Ако не влезе в "if", отиваме в "else-a". Щом сме в елса това означава, че при 
	разпакетирането на файла има директория, в която са "txt" формат. 
	(ред 52) разпакетирам файла в директорията подадена като пети аргумент на 
	функцията и пренасочвам грешките и изхода на командата към "/dev/null", за да 
	няма никакъв изход на екрана и проверявам статус кода, дали командата се е 
	изпълнила успешно. (ред 55) с командата "find" намирам всички директории с 
	ниво 1 и с командата "xargs" ги копирам рекурсивно в директорията подадена 
	като трети аргумент на скрипта. (ред 58) проверявам дали при разпакетирането 
	се получава директория с пражилно име(коректният факултетен номер на студента).
	Ако е грешно името на директорията получена след разпакетирането стойността на 
	променливата "grd" става равно на 1.
	
	2.Проверявам дали шестият аргумент е равен на (zip), ако е така, операциите, 
	които извършвам са аналогични на (1.) с малката разлика, че при разпакетиране 
	използвам "unzip file -d directory" и при проверката за правилно име на 
	директорията получена при разпакетиране(ред 82 - разпакетирам в директорията 
	подадена като седми аргумент на функцията).

	3.Проверявам дали шестият аргумент е равен на (rar), ако е така, операциите, 
	които извършвам са аналогични на (1.) с малката разлика, че при разпакетиране 
	използвам "unrar x file directory" и при проверката за правилно име на 
	директорията получена при разпакетиране(ред 106 - разпакетирам в директорията 
	подадена като седми аргумент на функцията).
	
	Ако не влезе в нито един от трите случая, това означава, че при извикване 
	на функцията, шестият аргумент не е подаден правилно. Извиквам функцията 
	"error_fn()", която вади съобшение за грешка. Така приключвам фунцията.

След дефинирането на функциите зпочват проверките за аргументи:
	1. Проверявам дали броят на аргументите е различен от 4.
	2. Втората проверка е дали първият аргумент е съществуващ файл.
	3. Третата проверка е дали файла подаден като първи аргумент е зип-нат файл.
	4. Проверявам дали вторият аргумент съществува.
	5. Проверявам дали третият аргумент съществува.
	6. Проверявам дали четвъртият аргумент съществува.

Създавам две директории, които са с имена втори и трети аргумент.
Проверявам статус кода на изпълнената команда.
Създавам фаил с име четвърти аргумент.
Проверявам статус кода на изпълнената команда.

Правя (временна) директория, в който ще ънзипвам първият аргумент.
Ънзипвам първият аргумент в (временна) директорията, която съм създал и 
ако има някакви ерори ги редиректвам към /dev/null.
Проверявам статус кода на унзипването.

Пускам цикъл, който на всяко завъртане ще работи с файла, на всеки студент, 
който трябва да бъде разпакетиран и вътре извършвам следните операции:

	Създавам 9 (временни) директории, които ще ползвам за място където да разпакетирам.
	Създавам си 4 променливи, които ще съдържат стойностите за грешки:
		1. гри - грешно име на файла
		2. грф - грешен формат на файла
		3. нд - липда на директория
		4. грд - грешно име на директорията

	Запазвам в променливи правилният факултетен номер, 
	формата на файла и името на файла без разширението
	
	Проверявам дали файлът завърщва с правилният формат.
	Следват седем проверки, с които проверявам формата и ако е от изброените в условието,
	разпакетирам и проверявам извънредните случаи, ако формата не е от изброените
	влизаме в (elsе)-а, където просто местим фаила в директорията с име третия 
	аргумент на скрипта. 
	
	Правя проверка на името, дали е като факултетният номер.
	
	Записвам информацията (фн, гри, грф, нд, грд) във файла създаден с име 
	четвърти аргумент.

	Изтривам (временните) файловете които съм направил.

Изтривам и директорията в която съм ънзипнал първият аргумент.

Принтя на изхода съобщение за успешно изпълнен скрипт и екзекютвам с код 0.
